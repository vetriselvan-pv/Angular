
HostBinding in angular 

Hey devs 
 In the series of exploring decorators in angular. Today, Let check the @HostBinding decorators How to use , How is got complied , and some special cases we never tried . 
Ok , Let start with what is HostBinding. 


what is HostBinding ? 
Decorator that marks a DOM property or an element class, style or attribute as a host-binding property and 
supplies configuration metadata. Angular automatically checks host bindings during change detection,
 and if a binding changes it updates the host element of the directive.

 syntax :
  @HostBinding ({
  hostPropertyName?: string | undefined;
})

You can define the DOM property as look below. 
        classes, prefixed by class.
        styles, prefixed by style.
        attributes, prefixed by attr.

Example :
    We are going to create a login form . To breifly explain the use of hostBinding . 

    html : 

    <div class="main-wrapper">
    <div class="form-container">
         <div class="logo-container">
        Login
      </div>
       <form [formGroup]="formGroup" class="form">
        <div class="form-group">
          <label for="username">Username</label>
          <input type="text"  formControlName="username" placeholder="Enter your username"  >
        </div>
         <div class="form-group">
          <label for="password">Password</label>
          <input type="text" formControlName="password" placeholder="Enter your password"  >
        </div>

        <button class="form-submit-btn" type="submit">Submit</button>
      </form> 
       
    </div>
</div>


scss

.invalid {
  border: 1px solid red !important;
}

.pending {
   border: 1px solid orange !important;
}

.main-wrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100dvw;
  height: 100dvh;
  background-color: #e9f5be;
  .form-container {
    width: 500px;
    background-color: #fff;
    padding: 32px 24px;
    font-size: 14px;
    font-family: inherit;
    color: #212121;
    display: flex;
    flex-direction: column;
    gap: 20px;
    box-sizing: border-box;
    border-radius: 10px;
    box-shadow: 0px 0px 3px rgba(0, 0, 0, 0.084),
      0px 2px 3px rgba(0, 0, 0, 0.168);
  }

  .form-container button:active {
    scale: 0.95;
  }

  .form-container .logo-container {
    text-align: center;
    font-weight: 600;
    font-size: 18px;
  }

  .form-container .form {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .form-container .form-group {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .form-container .form-group label {
    display: block;
    margin-bottom: 5px;
  }

  .form-container .form-group input {
    padding: 12px 16px;
    border-radius: 6px;
    font-family: inherit;
    border: 1px solid #ccc;
  }

  .form-container .form-group input::placeholder {
    opacity: 0.5;
  }

  .form-container .form-group input:focus {
    outline: none;
    border-color: #1778f2;
  }

  .form-container .form-submit-btn {
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: inherit;
    color: #fff;
    background-color: #212121;
    border: none;
    width: 100%;
    padding: 12px 16px;
    font-size: inherit;
    gap: 8px;
    margin: 12px 0;
    cursor: pointer;
    border-radius: 6px;
    box-shadow: 0px 0px 3px rgba(0, 0, 0, 0.084),
      0px 2px 3px rgba(0, 0, 0, 0.168);
  }

  .form-container .form-submit-btn:hover {
    background-color: #313131;
  }

  .form-container .link {
    color: #1778f2;
    text-decoration: none;
  }

  .form-container .signup-link {
    align-self: center;
    font-weight: 500;
  }

  .form-container .signup-link .link {
    font-weight: 400;
  }

  .form-container .link:hover {
    text-decoration: underline;
  }
}


ts file : 

import { CommonModule } from '@angular/common';
import { Component, inject, OnInit } from '@angular/core';
import {
  AbstractControl,
  AsyncValidatorFn,
  FormBuilder,
  FormGroup,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';
import { RouterLink } from '@angular/router';
import { Formfield } from '../../directive/formfield';
import { delay, map, of, timer } from 'rxjs';

@Component({
  selector: 'app-login',
  imports: [ReactiveFormsModule, CommonModule, RouterLink, Formfield],
  templateUrl: './login.html',
  styleUrl: './login.scss',
})
export class Login {
  private formBuilder: FormBuilder = inject(FormBuilder);

  result: string = 'start';

  formGroup: FormGroup = this.formBuilder.nonNullable.group({
    username: ['', [Validators.required],[this.userExistsValidator()]],
    password: ['', [Validators.required]],
  });


  userExistsValidator():AsyncValidatorFn  {
    return (control: AbstractControl) => {
        return  of(null).pipe(delay(2000))
    }
}

  constructor() { 
  }

  
 
}

In the above example we created a directive to attach the css class dynamically
 based on the status of the control and addition to that  we are adding the attribute id to the control . 
 and async Validators is added for the purpose of adding the pending status css. 
 In the below screenshot you can understand that the hostBinding happens based on the user interaction with the formcontrol (input).

 Note : 

    Based on the selector used hostPropertyName will be varey. incase if you are selector is input some of property are listed below.  
    @HostBinding('hidden') isDisabled = false;  

    ### ‚å®Ô∏è **Typing and Focus**

| Property                          | Description                                   |
| --------------------------------- | --------------------------------------------- |
| `type`                            | The type of the input (`text`, `email`, etc.) |
| `name`                            | Name of the input field                       |
| `placeholder`                     | Placeholder text                              |
| `spellcheck`                      | Whether spell checking is enabled             |
| `tabIndex`                        | Keyboard tab order                            |
| `accessKey`                       | Shortcut key to focus the input               |
| `selectionStart` / `selectionEnd` | Text selection positions                      |

### üß≠ **Attributes for Behavior**

| Property       | Description                                      |
| -------------- | ------------------------------------------------ |
| `disabled`     | Whether the input is disabled                    |
| `readonly`     | Whether the input is read-only                   |
| `required`     | Whether the input is required                    |
| `autofocus`    | Automatically focus the input on load            |
| `multiple`     | Allows multiple file selection (for type="file") |
| `autocomplete` | Suggests values based on past input              |

### üîç **Validation and Constraints**

| Property       | Description                           |
| -------------- | ------------------------------------- |
| `min`          | Minimum acceptable value              |
| `max`          | Maximum acceptable value              |
| `minLength`    | Minimum number of characters          |
| `maxLength`    | Maximum number of characters          |
| `pattern`      | Regex pattern the value must match    |
| `step`         | Step interval for numeric input       |


what happening under the hood ? 

    Basically the above directive will be complied to ivy commands as below 
    
    ivy file : 

    static \u0275dir = /* @__PURE__ */
    i0.\u0275\u0275defineDirective({
        type: _Formfield,
        selectors: [["", "formControlName", ""]],
        hostVars: 7,
        hostBindings: function Formfield_HostBindings(rf, ctx) {
            if (rf & 2) {
                i0.\u0275\u0275domProperty("id", ctx.formControlName);
                i0.\u0275\u0275styleProp("color", ctx.validColor);
                i0.\u0275\u0275classProp("invalid", ctx.invalid)("pending", ctx.pending);
            }
        },
        inputs: {
            formControlName: "formControlName"
        }
    });

    From that we can clearly understand based on the attribute we added will be defined as domProperty,styleProp and classProp. 

    Then in the browser the ivy commands will be executed . 
    …µ…µdomProperty will set the property to the element 

    export function …µ…µdomProperty<T>(
  propName: string,
  value: T,
  sanitizer?: SanitizerFn | null,
): typeof …µ…µdomProperty {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    setDomProperty(tNode, lView, propName, value, lView[RENDERER], sanitizer); // set the dom property
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return …µ…µdomProperty;
}
 
            setProperty(el: RElement, name: string, value: any): void {
            (el as any)[name] = value;
    } 

it basically used the DOM element by using the above method.

 
 
********************************. ********************************. ********************************. ********************************. ********************************. ********************************.  ********************************. ******************************** ********************************
 

# üîß Understanding `@HostBinding` in Angular with a Real Login Form Example

When working with Angular, one of the most powerful tools at your disposal is the `@HostBinding` decorator. Yet, for many developers, it remains a somewhat mysterious feature‚Äîespecially when it comes to applying it effectively in real-world scenarios.

In this post, we‚Äôll demystify `@HostBinding`, walk through a concrete use case with a styled login form, and even peek under the hood to see how Angular compiles and executes these bindings internally.

---

## ü§î What is `@HostBinding`?

`@HostBinding` is a decorator in Angular that allows a directive or component to **bind to a property of the host element**. It‚Äôs commonly used to set attributes, classes, styles, or other DOM properties dynamically, in response to internal component state.

In simple terms: you write code, and Angular makes sure the host element reflects your logic.

```ts
@HostBinding('class.active') isActive = false;
@HostBinding('attr.aria-label') label = 'Submit';
@HostBinding('style.color') color = 'blue';
```

### Syntax:

```ts
@HostBinding({
  hostPropertyName?: string | undefined;
})
```

The key here is the `hostPropertyName`, which tells Angular **which property, class, or attribute of the DOM element** you want to bind.

You can prefix your bindings to distinguish between:

* `class.` ‚Äî for CSS classes
* `style.` ‚Äî for inline styles
* `attr.` ‚Äî for attributes


## üß™ Real Example: A Reactive Login Form with Dynamic Styling

Let‚Äôs create a login form where form input fields update their styling based on validation state. We'll use `@HostBinding` inside a custom directive to dynamically assign classes like `invalid` or `pending`.

### üí° Why Use `@HostBinding` Here?

Rather than manually toggling classes in the component, we'll let our directive handle that. It will react to `FormControl` states and apply CSS classes automatically‚Äîelegant and reusable.


### üìù Login Form Template (`login.html`)

```html
<div class="main-wrapper">
  <div class="form-container">
    <div class="logo-container">Login</div>
    <form [formGroup]="formGroup" class="form">
      <div class="form-group">
        <label for="username">Username</label>
        <input type="text" formControlName="username" placeholder="Enter your username">
      </div>
      <div class="form-group">
        <label for="password">Password</label>
        <input type="password" formControlName="password" placeholder="Enter your password">
      </div>
      <button class="form-submit-btn" type="submit">Submit</button>
    </form>
  </div>
</div>
```


### üé® Styling (SCSS)

We‚Äôll define dynamic classes to reflect form control state.

```scss
.invalid {
  border: 1px solid red !important;
}

.pending {
  border: 1px solid orange !important;
}
```

We also have full UI styles for the form container, buttons, and more, making it a complete responsive login component.


### üß† Component Code (`login.ts`)

```ts
@Component({
  selector: 'app-login',
  imports: [ReactiveFormsModule, CommonModule, RouterLink, Formfield],
  templateUrl: './login.html',
  styleUrl: './login.scss',
})
export class Login {
  private formBuilder: FormBuilder = inject(FormBuilder);

  formGroup: FormGroup = this.formBuilder.nonNullable.group({
    username: ['', [Validators.required], [this.userExistsValidator()]],
    password: ['', [Validators.required]],
  });

  userExistsValidator(): AsyncValidatorFn {
    return (control: AbstractControl) => {
      return of(null).pipe(delay(2000)); // Simulates async validation
    };
  }
}
```

> The directive (`Formfield`) uses `@HostBinding` to attach CSS classes and even an `id` attribute to the input based on form control state.


## üîç Inside the Custom Directive

In your custom directive, you might have something like:

```ts
@Directive({
  selector: '[formControlName]',
})
export class Formfield {
  @HostBinding('class.invalid') get isInvalid() {
    return this.control?.invalid && this.control?.touched;
  }

  @HostBinding('class.pending') get isPending() {
    return this.control?.status === 'PENDING';
  }

  @HostBinding('attr.id') get id() {
    return this.controlName;
  }
}
```

The directive reacts to changes in `FormControl` status and automatically applies the correct classes.


## üõ†Ô∏è Under the Hood: Ivy Compilation

When Angular compiles your directive with Ivy, it converts your `@HostBinding` declarations into low-level instructions. Here's what it looks like:

```ts
hostBindings: function Formfield_HostBindings(rf, ctx) {
  if (rf & 2) {
    …µ…µdomProperty('id', ctx.formControlName);
    …µ…µstyleProp('color', ctx.validColor);
    …µ…µclassProp('invalid', ctx.invalid)('pending', ctx.pending);
  }
}
```

### ü§ñ Breakdown:

* `…µ…µdomProperty()` sets DOM attributes.
* `…µ…µclassProp()` toggles classes.
* `…µ…µstyleProp()` applies inline styles.

Angular checks these bindings during each change detection cycle and updates the host element if any values have changed.


## üìå Host Properties You Can Bind

Depending on the host element (like `input`), these are common bindings:

### ‚å®Ô∏è Typing & Focus

| Property      | Description                           |
| ------------- | ------------------------------------- |
| `type`        | Input type (`text`, `password`, etc.) |
| `placeholder` | Input placeholder text                |
| `tabIndex`    | Keyboard tab order                    |
| `accessKey`   | Keyboard shortcut                     |

### üß≠ Behavioral Attributes

| Property    | Description            |
| ----------- | ---------------------- |
| `disabled`  | Disable the input      |
| `readonly`  | Make input read-only   |
| `required`  | Mark as required       |
| `autofocus` | Autofocus on page load |

### üîç Validation Attributes

| Property    | Description        |
| ----------- | ------------------ |
| `minLength` | Minimum characters |
| `maxLength` | Maximum characters |
| `pattern`   | Regex pattern      |


## üß© Final Thoughts

`@HostBinding` is a powerful way to encapsulate logic and keep your Angular templates clean. By binding directly to DOM properties, attributes, or styles, you gain fine-grained control over your components‚Äîwithout cluttering your templates.

Using it with form validation and dynamic styling, as we did in this login form, is a practical and elegant solution. The result? Clean HTML, smart directives, and maintainable code.


### üß† TL;DR

* Use `@HostBinding` to dynamically bind to host element properties.
* Great for adding/removing classes based on logic.
* Integrates beautifully with Angular forms and directives.
* Under the hood, Angular converts it to efficient Ivy instructions.


Have you used `@HostBinding` in your projects? Share your use cases or questions in the comments‚Äîlet‚Äôs learn from each other!

 

Hey Devs , 

    Welcome back to our decorator series . It took long time to again do this. Let check the todays topic @pipe decorator. 

Pipe : 
    Pipe is a class having transform method used to transform the value without changing the original value. 
    
syntax : 

    @Pipe ({
  name: string;
  pure?: boolean | undefined;
  standalone?: boolean | undefined;
})

    name : name used to define the pipe in template binding ( must be lowerCamelCase )
    pure : its a boolean value , based on this transform method will be invoked.

Type : 
    pipe is differeniated based on the pure defined in the @pipe decorator. 
    when the pure is true or undefined ( bby default it is true) it is considered as pure pipe and transform method will be invoked at the time of input arguments changes 
    if it defined as false . then it is impure pipes. the transform method will be invoked on each change-detection cycle. 

Angular inbuild pipes : 

 most commonly used Angular built-in pipes along with their descriptions:

| Pipe Name      | Description                                                                                   |
|----------------|----------------------------------------------------------------------------------------------|
| DatePipe       | Formats a date value according to locale rules.                                              |
| UpperCasePipe  | Transforms text to all uppercase letters.                                                    |
| LowerCasePipe  | Transforms text to all lowercase letters.                                                    |
| CurrencyPipe   | Transforms a number to a currency string, formatted according to locale rules.               |
| DecimalPipe    | Transforms a number into a string with a specified decimal format.                           |
| PercentPipe    | Transforms a number to a percentage string.                                                  |
| JsonPipe       | Converts a value into its JSON string representation.                                        |
| SlicePipe      | Creates a new array or string containing a subset (slice) of the elements.                   |
| AsyncPipe      | Subscribes to an Observable or Promise and returns the latest value it has emitted.          |
| TitleCasePipe  | Capitalizes the first letter of each word in a string.                                       |
| KeyValuePipe   | Transforms an object or Map into an array of key-value pairs.                                |
| I18nPluralPipe | Transforms a number to a pluralized string, based on locale rules and a mapping configuration.|
| I18nSelectPipe | Selects a string from a set of messages based on a given value.                              |

Let see the uses and implemtation of the build in pipe in as seperate series. 

Custom Pipe : 
    Angular extends the pipe to handle your own bussiness logic by creating a custom pipe. 
    schematic to create a custom pipe . 
        ng g p <pipe-name>
    
Example : 

    Create a phone format pipe . the purpose of the pipe is to format the phone number. 

    phone-format.pipe.ts 

        import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'phoneFormat'
})
export class PhoneFormatPipe implements PipeTransform {

  transform(value: unknown, ...args: unknown[]): unknown {
    if(typeof value === 'string'){
      return value.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
    }
    return value;
  }

}

Html 
<h3>Pipe Decorator</h3>

<div class="text-wrapper">
  <div class="text">
    <textarea
      class="textarea-modern"
      [(ngModel)]="phoneNumber"
      name="subject" 
      maxlength="10"
      id="subject"
    ></textarea>
    <div class="btn-container"> 
      <button class="btn-ghost"  (click)="addNumber()" type="button">
        add
      </button>
    </div>
  </div>
  <div class="example">
    @for (item of numberArray(); track $index) {  
    <div class="card">
      <div class="index">{{$index}}</div>
      <div class="data"> Formatted value : {{ item | phoneFormat }}</div>
      <div class="data"> Raw value : {{ item }}</div>
    </div>
    }
  </div>
</div>

ts 
    import { Component, model, signal } from '@angular/core';
import { PhoneFormatPipe } from '../../pipes/phone-format-pipe';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-pipe-decorator-example',
  imports: [PhoneFormatPipe, FormsModule],
  templateUrl: './pipe-decorator-example.html',
  styleUrl: './pipe-decorator-example.scss'
})
export class PipeDecoratorExample {
  phoneNumber = model('');
  numberArray = signal<string[]>([]);

  addNumber() {
    this.numberArray.update(prev => [...prev, this.phoneNumber()]);
    this.phoneNumber.set('')
  }
}

Note : 
  Pipe just transform the value not change the original value.
 
Case 1 : 
Let the enter the phone number and format it using phoneFormat pipe. 
In the right side you can see the formatted value and the raw value. and i can understand what going on in your mind. we created a pipe is it pure or impure pipe right ?
Let me show it by console it . 
Bydefault the pipe will be pure which means when the input changes the transform will invoked. 
Let console the transform method and identify that 

In the above screenshot you can see the transform method got console once. At the time of gettig the value. 
Now Let change the pipe to impure 
    Inside the pipe decorator add the pure : false 

Now if you see the screenshot you can understand that the transform method got invoked when the change detection happens . 

Case 2 : Passing multiple arguments 

Now you mave have doubt that can i pass multiple arguments to pipe. the answer is yes you can pass . to explain that same phone format pipe we are to take with some simple modification .


 Example : 

    we are passing some data of phone number and country name  to the number array . Based on the country format is going to happens. 
    Check the code changes below . 

    html : 

     <div class="table-header">
      <div class="index">Index</div>
      <div class="country">Country Name</div>
      <div class="phoneNumber">Phone Number</div>
      <div class="formattedValue">Formatted Value</div> 
    </div>
    @for (item of numberArray(); track $index) {  
    <div class="table-body">
      <div class="index">{{$index}}</div>
      <div class="country">{{item.country}}</div>
      <div class="phoneNumber">{{item.phoneNumber}}</div>
      <div class="formattedValue">{{ item.phoneNumber| phoneFormat : item.country }}</div> 
    </div>
    }

    ts file 

    import { Component, model, OnInit, signal } from '@angular/core';
import { PhoneFormatPipe } from '../../pipes/phone-format-pipe';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-pipe-decorator-example',
  imports: [PhoneFormatPipe, FormsModule],
  templateUrl: './pipe-decorator-example.html',
  styleUrl: './pipe-decorator-example.scss'
})
export class PipeDecoratorExample  implements OnInit{ 
  numberArray = signal<{ country: string, phoneNumber: string }[]>([]);

  ngOnInit(): void {
    this.numberArray.set([
      { country: 'USA', phoneNumber: '1234567890' },
      { country: 'UK', phoneNumber: '12345678900' },
      { country: 'India', phoneNumber: '1234567890' },
      { country: 'Australia', phoneNumber: '1234567890' },
      { country: 'Germany', phoneNumber: '123456789012' },
      { country: 'France', phoneNumber: '1234567890' },
      { country: 'Brazil', phoneNumber: '12345678907' },
      { country: 'Japan', phoneNumber: '12345678907' },
      { country: 'South Africa', phoneNumber: '12345678907' },
      { country: 'Russia', phoneNumber: '1234567890' },
    ])
  }
 
}

pipe.ts 

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'phoneFormat'
})
export class PhoneFormatPipe implements PipeTransform {

  transform(value: unknown, ...args: unknown[]): unknown {
    console.log('transform', value, args);
    if(typeof value === 'string' && args.length === 0){
      return value.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
    }else if(typeof value === 'string' && args.length && args[0]){
      return value.replace(this.patternPhoneNumber[args[0] as keyof typeof this.patternPhoneNumber], this.formatPhoneNumber[args[0] as keyof typeof this.formatPhoneNumber]);
    }
    return value;
  }

  formatPhoneNumber = {
    'USA': '($1) $2-$3',
    'UK' : '$1 $2',
    'India' : '+91 $1 $2',
    'Australia' : '$1 $2 $3',
    'Germany' : '$1 $2',
    'France' : '$1 $2 $3 $4 $5',
    'Brazil' : '($1) $2-$3',
    'Japan' : '$1-$2-$3',
    'South Africa' : '$1 $2 $3',
    'Russia' : '8 ($1) $2-$3-$4',
  }

  patternPhoneNumber = {
    'USA': /(\d{3})(\d{3})(\d{4})/,
    'UK': /(\d{5})(\d{6})/,
    'India' : /(\d{5})(\d{5})/,
    'Australia' : /(\d{4})(\d{3})(\d{3})/,
    'Germany' : /(\d{3})(\d{8})/,
    'France' : /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/,
    'Brazil' : /(\d{2})(\d{5})(\d{4})/,
    'Japan' : /(\d{3})(\d{4})(\d{4})/,
    'South Africa' : /(\d{3})(\d{3})(\d{4})/,
    'Russia' : /(\d{3})(\d{3})(\d{2})(\d{2})/,
  }

}

// screenshot will be attached here 

pure pipes are greatly efficient for performance.
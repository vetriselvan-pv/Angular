Hey Devs 

    We’re back with another weekly exploration — and this time, we’re diving into an interesting and rarely used concept in RxJS: AsyncSubject.

AsyncSubject : 
    What asyncSubejct do ? . Unlike Other Subject Async subject will emits the last value of the observbale to its subscriber. and that to only when the execution completes.
    Not able to fully understand right ? 
    Don't worry Let me explain that . 

    syntax : 

    const subject = new AsyncSubject();

    Example : 
    In the below example we are going to pass data to the asyncSubejct and subscribe using async pipe in angular. 

    html : 

 <h3>AsyncSubject</h3>

<div class="text-wrapper">
  <div class="text">
    <textarea
      class="textarea-modern"
      [(ngModel)]="asyncSubjectText"
      name="asyncSubject"
      id="asyncSubject"
    ></textarea>
    <div class="btn-container">
      <button class="btn-ghost" (click)="sendAsyncSubject()" type="button">
        send
      </button>
      <button class="btn-ghost" (click)="completeAsyncSubject()" type="button">
        Complete
      </button>
      <button class="btn-ghost" (click)="addAsyncSubject()" type="button">
        add
      </button>
    </div>
  </div>
  <div class="example">
    <p>User Input : </p>
    @for (data of asyncSubjectData(); track $index) {  
      <div class="card">
        <div class="index">{{$index}}</div>
        <div class="data">{{data | json}}</div>
      </div>
      }
    <p>Async Subject Value : </p>
    @for (item of asyncSubjectArray(); track $index) { @let data = asyncSubject
    | async ;
    <div class="card">
      <div class="index">{{$index}}</div>
      <div class="data">{{data | json}}</div>
    </div>
    }
  </div>
</div>


ts 

import { Component, model, OnInit, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AsyncSubject, BehaviorSubject, ReplaySubject, scan, Subject, tap } from 'rxjs';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-rxjs-operator',
  imports: [CommonModule, FormsModule],
  templateUrl: './rxjs-operator.html',
  styleUrl: './rxjs-operator.scss',
})
export class RxjsOperator implements OnInit{
 
  asyncSubject = new AsyncSubject(); 

  asyncSubjectArray = signal<number[]>([0]);
 
  asyncSubjectText = model<string>('');

  asyncSubjectData = signal<string[]>([]);
  
  addAsyncSubject() {
    this.asyncSubjectArray.update((prev) => [...prev, 1]);
  } 
 
   sendAsyncSubject() {
    this.asyncSubjectData.update((prev) => [...prev, this.asyncSubjectText()]);
    this.asyncSubject.next(this.asyncSubjectText());
  }
  
  completeAsyncSubject(){
    this.asyncSubject.complete();
  }
}


Case 1 : initialvalue 
    Same to the subject you can't define the initial value to the asyncSubejct . and if you see the null will be value by default to this subject. 

    // screenshot of asyc subject output 

Case 2 : Passing N value . 

    As shown in the screen you can enter what ever text we want and pass that to the asyncSubejct. But it will consider only the last value it got before the complete. 
    To Show that i just print both the user enter value and the subscribed value. 

    // screenshot of passing data

    Note : Once the AsyncSubject got complete if you pass new value means it won't considered. 

Case 3 : Creating dynamic subscribers and passing value . 

    You can subscribe to asyncSubejct in multi places but it will consider only the last value and the same time if you subscribe to the completed asyncSubejct. 
    Immediately your subscribe call back will be triggered with the last emitted value. 

    // screenshot for multi subscriber 


Under the Hood : 

 same like other kind of subject it extends the subject class . But the next and the complete method got overrided. and the next functionality will be triggered on the time of complete. 
    export class AsyncSubject<T> extends Subject<T> {

        next(value: T): void {
    if (!this._closed) {
      this._value = value;
      this._hasValue = true;
    }
  }

  complete(): void {
    const { _hasValue, _value, _isComplete } = this;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && super.next(_value!);
      super.complete();
    }
    }

Conclusion : 

Async Subject are used in rare and special kind of usecase. Example in the place of promise-like observable.  
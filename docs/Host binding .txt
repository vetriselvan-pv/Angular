
Hey developers, 

    In the series of exploring decorators in angular. Today, Let check the @HostListener decorators How to use , How is got complied , and some special cases we never tried . 
Ok , Let start with what is HostListener. 

HostListener:
    Decorator that declares a DOM event to listen for, and provides a handler method to run when that event occurs.

Syntax : 
    @HostListener(eventName: string, [args: string[]])

Example : 
Case 1 : 
    HostListener are used to listern the native DOM event . such as MouseEvent, KeyBoardEvents and so on. In the below example we are going to create a directive that listern the MouseEvent. 
    whenever the host element got foucsed we are going to do some action on it . 

    Created a directive which will capture the mouseover and mouseleave events for strong tag in the respective. On hover of the elements .we are dynamically adding a css class to the nativeelemet and mouseleft we are removing the css class from it . 

    ts : 
        import { Component } from '@angular/core';
import { ZoomIn } from '../../directive/zoom-in';

@Component({
  selector: 'app-about',
  imports: [ZoomIn],
  template: `<section>
    <h2>About Me</h2>
    <p>
      I‚Äôm a <strong>frontend developer</strong> with a strong focus on
      <strong>Angular</strong>, currently working with
      <strong>Angular 20</strong> and exploring advanced UI effects to enhance
      user experience.
    </p>
    <p>
      I enjoy integrating rich, interactive features like
      <em>text zoom lenses</em> using a combination of <strong>HTML</strong>,
      <strong>CSS</strong>, and <strong>TypeScript</strong>.
    </p>
    <p>
      I approach projects with a practical mindset, aiming to build clean,
      functional components that are easily maintainable within a modern Angular
      architecture.
    </p>
  </section>`,
  styleUrl: './about.scss',
})
export class About {
  constructor() { 
  }
}

zoom-in directive :  

    import { Directive, ElementRef, HostListener, inject, Renderer2 } from '@angular/core';

@Directive({
  selector: '<strong>'
})
export class ZoomIn {

  private _el : ElementRef = inject(ElementRef);
  private renderer : Renderer2 = inject(Renderer2);
  constructor( ) { }

  @HostListener('mouseover',['$event'])
  mouseOver(event: MouseEvent){ 
    this.renderer.addClass(this._el.nativeElement,'zoom')
  }

   @HostListener('mouseleave',['$event'])
  mouseLeave(event: MouseEvent){ 
    this.renderer.removeClass(this._el.nativeElement,'zoom')
  }

}

scss : 

    .zoom { 
  transition: transform 1s;  
}

.zoom:hover { 
font-size: 20px;
color: #81E7AF;
}

In the above example we discussed about the DOM events for selected host element. 

Meanwhile angular gave the provision to added the event to global target . It can be defined by using the global target in the prefix of the events .

Case 2 : 

    Instaead creating a directive we are going to add the hostListern to the component itself . 

      @HostListener('window:resize',['$event'])
        windowEvent(event:any){
            console.log(event)
     }

     Now we listern the window resize event. When the resize happends it will trigger the method registered with the resize. 
     Similar to window , you can registered document and body events also. 

Case 3 : 

    Here is the interesting topic came. can i register the specific keyevents how i can do it in javascript . The answer is yes. You can register a valid key names with keydown and keyup events . 
    For example i need to show a info alert about the page when the user clicks shift + i . So i did hostListern as follow. 


what happens inside the hood of HostListener

  Basically hostListern is a decorator provided by angular which means it a function inside the angular/core.

  export const HostListener: HostListenerDecorator = makePropDecorator(
  'HostListener',
  (eventName?: string, args?: string[]) => ({eventName, args}),
);

the above method will change the angular code in ivy command like below , then angular render will do its process . 

  hostBindings: function About_HostBindings(rf, ctx) {
            if (rf & 1) {
                i05.\u0275\u0275listener("resize", function About_resize_HostBindingHandler($event) {
                    return ctx.windowEvent($event);
                }, i05.\u0275\u0275resolveWindow)("keydown.shift.i", function About_keydown_shift_i_HostBindingHandler($event) {
                    return ctx.info($event);
                }, i05.\u0275\u0275resolveWindow);
            }
        },


----------------------- md file  -----------------------  -----------------------  -----------------------  -----------------------  -----------------------  -----------------------  -----------------------  -----------------------  -----------------------  
 

# üîç Exploring `@HostListener` in Angular ‚Äî How It Works, Use Cases, and Behind the Scenes

Hey developers! üëã

Welcome back to our series on Angular decorators. In this post, we're diving into one of the lesser-discussed but incredibly powerful decorators in Angular: `@HostListener`. We‚Äôll explore how to use it, how it gets compiled under the hood, and a few interesting use cases you may not have tried before.



## üéØ What is `@HostListener`?

The `@HostListener` decorator allows you to listen to DOM events on the **host element** of a directive or component and run custom logic in response. It‚Äôs a clean way to bind events without touching the template.

### üß† Syntax

```ts
@HostListener(eventName: string, [args: string[]])
```



## üß™ Use Case 1: Listening to DOM Events on Host Element

Let‚Äôs start with a basic example where we listen to native DOM events like `mouseover` and `mouseleave` to dynamically apply styles.

We‚Äôll create a directive that zooms in text when hovered.

### ‚úÖ Step 1: The Directive

```ts
import { Directive, ElementRef, HostListener, inject, Renderer2 } from '@angular/core';

@Directive({
  selector: 'strong', // Applies to all <strong> elements
})
export class ZoomIn {
  private _el = inject(ElementRef);
  private renderer = inject(Renderer2);

  @HostListener('mouseover', ['$event'])
  mouseOver(event: MouseEvent) {
    this.renderer.addClass(this._el.nativeElement, 'zoom');
  }

  @HostListener('mouseleave', ['$event'])
  mouseLeave(event: MouseEvent) {
    this.renderer.removeClass(this._el.nativeElement, 'zoom');
  }
}
```

### ‚úÖ Step 2: The Component

```ts
import { Component } from '@angular/core';
import { ZoomIn } from '../../directive/zoom-in';

@Component({
  selector: 'app-about',
  standalone: true,
  imports: [ZoomIn],
  template: `
    <section>
      <h2>About Me</h2>
      <p>
        I‚Äôm a <strong>frontend developer</strong> with a strong focus on
        <strong>Angular</strong>, currently working with
        <strong>Angular 20</strong> and exploring advanced UI effects to enhance
        user experience.
      </p>
    </section>
  `,
  styleUrls: ['./about.scss'],
})
export class About {}
```

### ‚úÖ Step 3: Styles (`about.scss`)

```scss
.zoom {
  transition: transform 1s;
}

.zoom:hover {
  font-size: 20px;
  color: #81E7AF;
}
```

> üéâ Result: When a user hovers over any `<strong>` tag, the zoom effect kicks in!



## üåê Use Case 2: Listening to Global Events (Window, Document, etc.)

`@HostListener` isn‚Äôt limited to the host element. Angular also allows you to bind global events like `window:resize`.

### Example:

```ts
@HostListener('window:resize', ['$event'])
onResize(event: Event) {
  console.log('Window resized', event);
}
```

You can also listen to other global targets like `document` or `body`:

```ts
@HostListener('document:click', ['$event'])
onDocumentClick(event: MouseEvent) {
  console.log('Document clicked', event);
}
```



## üéπ Use Case 3: Listening to Specific Key Combinations

You can use `@HostListener` to capture specific key events‚Äîjust like in plain JavaScript!

### Example: Show an alert when `Shift + I` is pressed

```ts
@HostListener('window:keydown.shift.i', ['$event'])
onShortcut(event: KeyboardEvent) {
  alert('Info shortcut triggered!');
}
```

This is super useful for building shortcuts or accessibility features directly into your components.



## üß© How `@HostListener` Works Under the Hood

Under the hood, `@HostListener` is just syntactic sugar provided by Angular. It‚Äôs implemented via Angular‚Äôs `makePropDecorator` function:

```ts
export const HostListener: HostListenerDecorator = makePropDecorator(
  'HostListener',
  (eventName?: string, args?: string[]) => ({ eventName, args }),
);
```

When compiled by Angular (Ivy), your decorator gets transformed into low-level host bindings like:

```ts
hostBindings: function About_HostBindings(rf, ctx) {
  if (rf & 1) {
    …µ…µlistener("resize", function About_resize($event) {
      return ctx.onResize($event);
    }, …µ…µresolveWindow);
    
    …µ…µlistener("keydown.shift.i", function About_shortcut($event) {
      return ctx.onShortcut($event);
    }, …µ…µresolveWindow);
  }
}
```

That‚Äôs how Angular internally registers the event listeners during render.



## üß† Final Thoughts

The `@HostListener` decorator is a clean, Angular-idiomatic way to handle DOM and global events. It:

* Keeps event handling logic close to the component or directive class
* Works seamlessly with Angular's DI and change detection
* Helps encapsulate behavior without touching templates

Whether you're creating reusable directives or handling responsive layouts, `@HostListener` can significantly streamline your codebase.



üí¨ **Got questions or use cases you want to share?** Drop a comment below! Let's discuss more Angular magic. ‚ú®


### ‚úçÔ∏è Author: [Vetriselvan](https://dev.to/vetriselvan_11)

üë®‚Äçüíª Frontend Developer | Code Lover | Exploring Angular‚Äôs future


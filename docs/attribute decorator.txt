
 @Attribute decorator in angular 

 Hi devlopers , 

 Just a another day while discussing with the collegues. We shared the interesting topic about decorators in typescript and 
started exploring the angular.dev . In that we found one of the intersting decorator and i just want to share it with all of you. 

@Attribute decorator : 

 we are using @Attribute rarely but still its one the powerful concept in angular .@Attribute means : 
 Parameter decorator for a directive constructor that designates a host-element attribute whose value is injected as a constant string literal.
  Bascially , 
 It allows a class (usually a component or directive) to access a static HTML attribute value at construction time, even if it's not bound to an Angular input. 
 
Let see how to implement the @Attribute in real time use case : 
 
In the below example i create a directive named FontType. which have the @Attribute decorator in the name of font. 

import { Attribute, Directive, ElementRef, inject, OnInit, Renderer2 } from '@angular/core';

@Directive({
  selector: '[fontType]'
})
export class FontType  implements OnInit{

  private render : Renderer2 = inject(Renderer2);
  private el : ElementRef  = inject(ElementRef)

  constructor( @Attribute('font') public font : 'underline' | 'italic' | 'bold' | null) { 
    console.log(font)
  }

  ngOnInit(): void {
     switch(this.font){
        case 'italic' : {
          this.render.setStyle(this.el.nativeElement ,'color','red');
           break;
        };
        case 'bold' : {
          this.render.setStyle(this.el.nativeElement ,'color','green');
           break;
        };
        case 'underline' : {
          this.render.setStyle(this.el.nativeElement ,'color','orange');
           break;
        };
        default : {
          console.log('font not provided')
        }
     }
  }

}

And i created a component to implement the FontType directive . the component will be below . 

import { Component } from '@angular/core';
import { FontType } from '../../directive/role';

@Component({
  selector: 'app-attribute',
  imports: [FontType],
  template: `<h1><u>About Me</u></h1>
    <p>
      I‚Äôm a <b>frontend developer</b> and
      <b fontType font="bold">freelancer</b> passionate about building
      beautiful, responsive, and user-friendly web interfaces.
    </p>
    <p>
      I specialize in <b><u fontType font="underline">HTML</u></b
      >, <b><u fontType font="underline">CSS</u></b
      >, <b><u fontType font="underline">JavaScript</u></b
      >, and modern frameworks like <b>React</b> and <b>Vue</b>. I enjoy turning
      complex problems into simple, elegant solutions.
    </p>
    <p>
      <i fontType font="italic"
        >I believe that great design is just as important as great code</i
      >, and I‚Äôm always exploring <u>new technologies</u> and tools to enhance
      user experience.
    </p>
    <p>
      Whether it‚Äôs building from scratch or bringing life to an existing
      project, I‚Äôm ready to help.
      <b
        ><i><u>Let‚Äôs create something amazing together!</u></i></b
      >
    </p>`,
  styleUrl: './attribute.scss',
})
export class About {
  constructor() {
    console.log('About');
  }
}

In the above html if you see the directives are added for certain tag ex. <b>, <u> and <i> . you can end result in the below screenshot. 
the function of directive is based on the font defined in the html the color will added to the text . 

as we know we have input decorator property to the same thing. why @Attribute is required ? . Well yeah it correct . but there is few difference between 
@Input and @Attribute .

Breakdown the difference between @Input and @Attribute 

@Atribute is just a static HTML attributes. will read the value during the constructor (gives access to raw attribute values at the time of construction.)

| Feature            | `@Input()`            | `@Attribute()`            |
| ------------------ | --------------------- | ------------------------- |
| When value is read | After instantiation   | During instantiation      |
| Reactive           | Yes                   | No                        |
| Source             | Angular bindings      | Static HTML attributes    |
| Use case           | Dynamic input binding | Accessing static metadata |


What happens under the hood 
  Angular compilers process the directive into ivy command as follow : 

   var FontType = class _FontType {
    font;
    render = inject3(Renderer2);
    el = inject3(ElementRef);
    constructor(font) {
        this.font = font;
        console.log(font);
    }
    ngOnInit() {
        switch (this.font) {
        case "italic":
            {
                this.render.setStyle(this.el.nativeElement, "color", "red");
                break;
            }
            ;
        case "bold":
            {
                this.render.setStyle(this.el.nativeElement, "color", "green");
                break;
            }
            ;
        case "underline":
            {
                this.render.setStyle(this.el.nativeElement, "color", "orange");
                break;
            }
            ;
        default:
            {
                console.log("font not provided");
            }
        }
    }
    static \u0275fac = function FontType_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FontType)(i04.\u0275\u0275injectAttribute("font"));
    }
    ;
    static \u0275dir = /* @__PURE__ */
    i04.\u0275\u0275defineDirective({
        type: _FontType,
        selectors: [["", "fontType", ""]]
    });
}
;
( () => {
    (typeof ngDevMode === "undefined" || ngDevMode) && i04.\u0275setClassMetadata(FontType, [{
        type: Directive,
        args: [{
            selector: "[fontType]"
        }]
    }], () => [{
        type: void 0,
        decorators: [{
            type: Attribute,
            args: ["font"]
        }]
    }], null);
}
)();

decorator Attribute will be executed by the angular ivy and the repective value will be injected to the font args. as shown in the below screenshot . 
at the same time in the component ivy compiled code . 


üö´ When Not to Use It
When the attribute is bound dynamically via Angular (use @Input() instead).

When you need to track changes (since @Attribute() is static).

Now we can check one more thing incase if i manually change the attribute after component init or view init what wil happen ? 

in the directive : 

 ngAfterViewInit(): void {
    console.log('Before changing the attribute value : ',this.font);
    this.render.setAttribute(this.el.nativeElement,'font', 'some_random_value');
    console.warn('After changing the attribute value : ',this.font)
  }

If you see the below screenshot it will clearly shows that the @Attribute is static and will assign value on constructor . If the value got changed dynamically also it won't get updated. 





---

##Medium 

 

````markdown
# üîç `@Attribute` Decorator in Angular ‚Äî A Hidden Gem You Should Know

Hey developers üëã,

The other day during a casual team discussion, we stumbled upon something interesting while diving deep into Angular's decorator system. Amid the usual suspects like `@Input`, `@Output`, and `@Inject`, we rediscovered a lesser-used but **powerful** decorator ‚Äî `@Attribute`.

I hadn‚Äôt paid much attention to this one before, so I decided to explore it further. And now I‚Äôm here to share my findings with all of you!

---

## üß† What Is `@Attribute()`?

The `@Attribute()` decorator is a **parameter decorator** used inside a directive or component constructor. It tells Angular to **inject a static attribute value** from the host HTML element **as a constant string literal** at construction time.

In simple terms:  
> `@Attribute()` lets your directive or component **access raw HTML attribute values** directly ‚Äî even if they aren‚Äôt bound with Angular syntax.

This is especially useful when you need **static metadata** at initialization that won‚Äôt change.

---

## üîß Real-World Use Case ‚Äî Font Styling Directive

Let‚Äôs walk through an example. Here, we‚Äôll create a custom directive `FontType` that changes the font color based on the value of a static HTML attribute called `font`.

### üéØ Directive Code

```ts
import { Attribute, Directive, ElementRef, inject, OnInit, Renderer2 } from '@angular/core';

@Directive({
  selector: '[fontType]'
})
export class FontTypeDirective implements OnInit {
  private render = inject(Renderer2);
  private el = inject(ElementRef);

  constructor(@Attribute('font') public font: 'underline' | 'italic' | 'bold' | null) {
    console.log('Injected font:', font);
  }

  ngOnInit(): void {
    switch (this.font) {
      case 'italic':
        this.render.setStyle(this.el.nativeElement, 'color', 'red');
        break;
      case 'bold':
        this.render.setStyle(this.el.nativeElement, 'color', 'green');
        break;
      case 'underline':
        this.render.setStyle(this.el.nativeElement, 'color', 'orange');
        break;
      default:
        console.log('Font not provided');
    }
  }
}
````

---

### üí° Usage in a Component

```ts
@Component({
  selector: 'app-about',
  standalone: true,
  imports: [FontTypeDirective],
  template: `
    <h1><u>About Me</u></h1>
    <p>
      I‚Äôm a <b>frontend developer</b> and
      <b fontType font="bold">freelancer</b> passionate about building
      beautiful, responsive, and user-friendly web interfaces.
    </p>
    <p>
      I specialize in <b><u fontType font="underline">HTML</u></b>,
      <b><u fontType font="underline">CSS</u></b>,
      <b><u fontType font="underline">JavaScript</u></b>,
      and modern frameworks like <b>React</b> and <b>Vue</b>.
    </p>
    <p>
      <i fontType font="italic">
        I believe that great design is just as important as great code
      </i>
    </p>
  `
})
export class AboutComponent {
  constructor() {
    console.log('AboutComponent initialized');
  }
}
```

In the HTML, you can see the `fontType` directive applied to elements like `<b>`, `<u>`, and `<i>`. The color styling is applied based on the value of the `font` attribute.

---

## ‚ùì Why Use `@Attribute()` Instead of `@Input()`?

That‚Äôs a great question.

`@Input()` is designed for **dynamic Angular bindings** like `[font]="fontValue"`, while `@Attribute()` is ideal for **static attribute values** defined in the raw HTML.

Here‚Äôs a comparison:

| Feature            | `@Input()`         | `@Attribute()`         |
| ------------------ | ------------------ | ---------------------- |
| When value is read | After construction | During construction    |
| Reactive           | ‚úÖ Yes              | ‚ùå No                   |
| Source             | Angular bindings   | Static HTML attribute  |
| Use case           | Dynamic behavior   | Static config/metadata |

---

## üß™ Under the Hood ‚Äî How Angular Compiles `@Attribute()`

When Angular compiles your directive with Ivy, it generates internal code that injects the attribute directly into the constructor. Here‚Äôs a simplified view of what happens:

```ts
static …µfac = function FontType_Factory(t) {
  return new (t || FontType)(…µ…µinjectAttribute('font'));
};
```

So in essence, the `@Attribute('font')` decorator becomes a low-level call to Angular‚Äôs internal `injectAttribute()` helper, and the string value is passed directly to the constructor.

> This injection is **static and one-time** ‚Äî it happens during instantiation and does **not** respond to changes in the attribute later.

---

## ‚ö†Ô∏è Gotchas ‚Äî When Not to Use `@Attribute()`

* **‚ùå Don't use it with Angular bindings.** If your attribute is dynamic (`[font]="value"`), use `@Input()` instead.
* **‚ùå Don‚Äôt expect it to update.** Changing the attribute manually after construction won‚Äôt update the injected value.

Let‚Äôs demonstrate this:

```ts
ngAfterViewInit(): void {
  console.log('Before change:', this.font);
  this.render.setAttribute(this.el.nativeElement, 'font', 'some_other_value');
  console.log('After change:', this.font);  // Still prints the original value
}
```

Result: The logged value won‚Äôt change ‚Äî `@Attribute()` reads the attribute once at construction time and never again.

---

## üßµ Conclusion

The `@Attribute()` decorator is a quiet but powerful feature of Angular‚Äôs DI system. It‚Äôs useful when you need **static, non-reactive data** that doesn't rely on Angular's change detection or binding system.

Use it:

* For reading raw attribute values (like `type`, `role`, or `font`).
* When you don‚Äôt want the overhead of Angular bindings.
* Inside directives or components that rely on metadata from the host element.



üß† **Pro tip**: Think of `@Attribute()` as the Angular equivalent of calling `element.getAttribute('foo')`, but in a type-safe, DI-friendly way.



Let me know if you've used `@Attribute()` in any unique way ‚Äî or if you'd like me to turn this into a StackBlitz demo you can try out live! üöÄ

```
 

Here's your updated content restructured and polished into a complete, Medium-style blog post (with Markdown formatting):

---

# üéØ Rediscovering Angular‚Äôs Hidden Gem: `@Attribute()` Decorator

Hey developers üëã,

The other day during a casual team discussion, we stumbled upon something interesting while diving deep into Angular‚Äôs decorator system. Amid the usual suspects like `@Input`, `@Output`, and `@Inject`, we rediscovered a lesser-used but powerful decorator‚Ää‚Äî‚Ää`@Attribute`.

Honestly, I hadn‚Äôt paid much attention to it before. But after taking a deeper look, I found it pretty useful for specific scenarios ‚Äî and now I‚Äôm here to share those findings with you!

---

## üß† What Is `@Attribute()`?

The `@Attribute()` decorator is a **parameter decorator** used inside a component or directive constructor. It tells Angular to **inject a static attribute value** from the host HTML element **as a constant string literal** during instantiation.

In simpler terms:

> `@Attribute()` allows your directive or component to **access raw, static HTML attribute values** ‚Äî even if they‚Äôre not bound using Angular syntax.

This is especially handy when you need **static metadata** at initialization that isn‚Äôt expected to change.

---

## üîß Real-World Use Case‚Ää‚Äî‚ÄäFont Styling Directive

Let‚Äôs walk through a real example. We‚Äôll create a custom directive called `FontType` that changes the font color based on a custom static HTML attribute: `font`.

### ‚ûï Step 1: Define the Directive

```ts
import { Attribute, Directive, ElementRef, inject, OnInit, Renderer2 } from '@angular/core';

@Directive({
  selector: '[fontType]'
})
export class FontType implements OnInit {

  private render: Renderer2 = inject(Renderer2);
  private el: ElementRef = inject(ElementRef);

  constructor(@Attribute('font') public font: 'underline' | 'italic' | 'bold' | null) {
    console.log('Injected font attribute:', font);
  }

  ngOnInit(): void {
    switch (this.font) {
      case 'italic':
        this.render.setStyle(this.el.nativeElement, 'color', 'red');
        break;
      case 'bold':
        this.render.setStyle(this.el.nativeElement, 'color', 'green');
        break;
      case 'underline':
        this.render.setStyle(this.el.nativeElement, 'color', 'orange');
        break;
      default:
        console.log('No font attribute provided.');
    }
  }
}
```

---

### ‚ûï Step 2: Use It in a Component Template

```ts
@Component({
  selector: 'app-attribute',
  standalone: true,
  imports: [FontType],
  template: `
    <h1><u>About Me</u></h1>
    <p>
      I‚Äôm a <b>frontend developer</b> and
      <b fontType font="bold">freelancer</b> passionate about building
      responsive, user-friendly web interfaces.
    </p>
    <p>
      I specialize in <b><u fontType font="underline">HTML</u></b>,
      <b><u fontType font="underline">CSS</u></b>,
      <b><u fontType font="underline">JavaScript</u></b>, and frameworks like <b>React</b> and <b>Vue</b>.
    </p>
    <p>
      <i fontType font="italic">I believe great design is just as important as great code.</i>
    </p>
  `
})
export class AboutComponent {
  constructor() {
    console.log('AboutComponent initialized');
  }
}
```

The directive reads the static `font` attribute and styles the text based on its value.

---

## üÜö `@Input()` vs `@Attribute()`

You might be asking ‚Äî why not just use `@Input()`? Here's how they differ:

| Feature            | `@Input()`                 | `@Attribute()`                |
| ------------------ | -------------------------- | ----------------------------- |
| When value is read | After component is created | During component construction |
| Reactive           | ‚úÖ Yes                      | ‚ùå No                          |
| Value source       | Angular binding            | Static HTML attribute         |
| Use case           | Dynamic props              | Static configuration          |

### When to Use `@Attribute()`

‚úÖ Use when:

* You want to read **static metadata** from the DOM.
* You need access to the attribute value **before any Angular bindings occur**.

üö´ Avoid when:

* You want to **react to changes**.
* You‚Äôre using **dynamic values** or two-way bindings (use `@Input()` instead).

---

## üî¨ Under the Hood: Ivy & Dependency Injection

Angular's Ivy compiler turns `@Attribute()` into an internal `…µ…µinjectAttribute()` call in the factory function:

```ts
static …µfac = function FontType_Factory(t) {
  return new (t || FontType)(…µ…µinjectAttribute('font'));
};
```

This means Angular will extract the attribute from the raw DOM at creation time and pass it directly to the directive or component constructor ‚Äî no binding, no change detection, just one static injection.

If you later modify the attribute manually via JavaScript or the DOM, the value inside the directive will **not update**, because Angular doesn‚Äôt track static attribute changes.

### Example:

```ts
ngAfterViewInit(): void {
  console.log('Before change:', this.font);
  this.render.setAttribute(this.el.nativeElement, 'font', 'new_value');
  console.log('After change:', this.font); // Still the original
}
```

---

## üß© Final Thoughts

The `@Attribute()` decorator is a subtle but effective tool when you need to:

* Access static, unchanging values at creation time.
* Avoid Angular‚Äôs reactivity or binding overhead for certain config values.
* Build lightweight, configuration-based directives.

It won‚Äôt replace `@Input()` in most day-to-day Angular use cases ‚Äî but when you do need it, it‚Äôs a clean and powerful solution.

---

üí¨ Have you ever used `@Attribute()` in a project? What other lesser-known Angular decorators have helped you write cleaner or more efficient code?

Drop your thoughts in the comments ‚Äî and happy coding! üöÄ

---

Would you like this exported as a `.md` file for publishing or hosting?

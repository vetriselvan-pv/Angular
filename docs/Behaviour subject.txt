
Hey Devs 

    We’re back with another weekly exploration — and this time, we’re diving into an interesting and widely used concept in RxJS: BehaviorSubject.

    Let imagine where i need to get the last emitted value when a new observer  

BehaviorSubject : 

    BehaviorSubject is nothing but a special variant of subject. Which stores the last emitted value to its consumers. 
    at the same time when new observer subscribe the last value will be emitted immediately. 
    Let try with example . 

    Note : When we create a BehaviorSubject we need to define the initialvalue. 

Html : 
    
    <h3>BehaviorSubject</h3>

<div class="text-wrapper">
  <div class="text">
    <textarea class="textarea-modern" [(ngModel)]="behaviorSubjectText" name="behaviorSubject" id="behaviorSubject"></textarea>
    <div class="btn-container">
      <button class="btn-ghost" (click)="sendBehaviorSubject()" type="button">send</button>
      <button class="btn-ghost" (click)="addBehaviorSubject()" type="button">add</button>
    </div>
  </div>
  <div class="example">
    @for (item of behaviorSubjectArray(); track $index) {
      @let data = behaviorSubject | async ; 
       <div class="card">
        <div class="index">{{$index}}</div>
        <div class="data">{{data | json}}</div>
       </div>
    }
  </div>
</div>

ts : 


import { Component, model, OnInit, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-rxjs-operator',
  imports: [CommonModule, FormsModule],
  templateUrl: './rxjs-operator.html',
  styleUrl: './rxjs-operator.scss',
})
export class RxjsOperator  {
    
  behaviorSubject = new BehaviorSubject('Hello this is behavior subject');

  behaviorSubjectArray = signal<number[]>([0]); 

  behaviorSubjectText = model<string>('');  
   
    addBehaviorSubject() {
    this.behaviorSubjectArray.update((prev) => [...prev, 1]);
  }
    sendBehaviorSubject() {
    this.behaviorSubject.next(this.behaviorSubjectText());
  }
 
}

Case : 1 

when the behaviorSubject initialize. the value will be  Hello this is behavior subject as shown in the below screenshot. 
<image output> 

Case : 2 
    Same Like subject you need to pass the new value use .next(). As shown in the below screenshot you can use when the user enter the value
     and click the send button behaviorSubject got updated. 
<image ouptut> 

case : 3 

    Let introduce new observer to the behaviorSubject . As show in the below screenshot click the add button will add new observer and you see magic happens 

Yes , unlike subject , the last emitted value will be emitted to the new observer. 

Under the hood: 

    Let see what happpens inside the behaviorSubject. 

    BehaviorSubject is also a class that extends Subject . which means it also have same properties of subject ex :( asObservable() )

    export class BehaviorSubject<T> extends Subject<T> {
  constructor(private _value: T) {
    super();
  }
    }

    if you the constructor have parameter . So you must define the initialvalue and the next got override here. So it just store the last value.

    next(value: T): void {
    super.next((this._value = value));
  }

  conclusion 
Hope you understand the concept of how subject is working . Let explore the replySubject in the next blog 